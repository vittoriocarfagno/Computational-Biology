from pathlib import Path
import numpy as np
from matplotlib import pyplot as plt
import pandas as pd

#src = Path.cwd()
#data_path = np.load("Lesson_18_Project_2_visual_stimulus_parameters.npz")
#data_path1 =  np.load("Lesson_18_Project_2_visual_responses.npy")

data_path = "C:/Users/u0049856/Desktop/computational_biology_2025/Lesson_18_Project_2_visual_stimulus_parameters.npz"
data_path1 = "C:/Users/u0049856/Desktop/computational_biology_2025/Lesson_18_Project_2_visual_responses.npy"

# Upload of data
with np.load(data_path) as par:
    spatial = par['spatial_frequency_by_degree']
    direction = par['direction_in_degrees']
    temporal = par['temporal_frequency_in_Hz']

resp = np.load(data_path1)


# Idea, just for visualization
df_resp = pd.DataFrame(resp)

df_par = pd.DataFrame({
    'spatial_frequency_by_degree': spatial,
    'direction_in_degrees': direction,
    'temporal_frequency_in_Hz': temporal
})


print(df_resp)
print(df_par)

spatial_freqs = np.unique(spatial)
print(spatial_freqs)

# Dictionary to store the matrices
matrici = {}

# Find unique directions and sort them
directions_sorted = np.sort(df_par.loc[:, 'direction_in_degrees'].unique())
print("Directions are", directions_sorted)

# Loop over each spatial frequency
for sf in spatial_freqs:
    # Rows corresponding to this spatial frequency
    rows_sf = df_par.index[df_par['spatial_frequency_by_degree'] == sf].tolist()

    # Create the matrix (384 neurons x 12 directions)
    mat = np.zeros((resp.shape[0], len(directions_sorted)))
    
    # Loop over the directions
    for i, dir_ in enumerate(directions_sorted):
        cols_dir = df_par.index[
            (df_par['spatial_frequency_by_degree'] == sf) & 
            (df_par['direction_in_degrees'] == dir_)
        ].tolist()
        # Average over the repetitions of this stimulus
        mat[:, i] = df_resp.iloc[:, cols_dir].mean(axis=1)
    
    # Save the matrix in the dictionary
    matrici[sf] = mat

# Now 'matrici' contains 3 matrices, keys = spatial frequencies

mat_004 = matrici[0.04]
mat_008 = matrici[0.08]
mat_016 = matrici[0.16]
print("Matrix 0.04 freq with dimensions: ", mat_004.shape)  # should be (384,12)
print(mat_004)
print("Matrix 0.08 freq with dimensions: ", mat_008.shape)  # should be (384,12)
print(mat_008)
print("Matrix 0.16 freq with dimensions: ", mat_016.shape)  # should be (384,12)
print(mat_016)

#example of evolution of neuron "0" freq 0.04
neuron_id = 0
tuning_curve = mat_004[neuron_id, :]
print(tuning_curve)

plt.figure(figsize=(6,4))
plt.plot(directions_sorted, tuning_curve, marker='o')
plt.xlabel("Direction (°)")
plt.ylabel("Response")
plt.title("Direction tuning – Neuron {}".format(neuron_id))
plt.grid(True)
plt.show()

### TASK 2.	Get the preferred motion direction of each neuron and strength of directional tuning by calculating 
# Preferred direction and Direction Selectivity Index (DSI)


preferred_direction = {}
DSI = {}

for sf in spatial_freqs:  # Loop over spatial frequencies
    mat = matrici[sf]     # Matrix: 384 neurons × 12 directions

    # creating empty storages
    preferred_direction[sf] = np.zeros(mat.shape[0])
    DSI[sf] = np.zeros(mat.shape[0])

    # Loop over each neuron
    for neuron in range(mat.shape[0]):

        # the neuron’s response across all stimulus directions
        responses = mat[neuron, :]

        # Complex vector sum
        vector_sum = np.sum(
            responses * np.exp(1j * directions_sorted / 180 * np.pi)
        )

        # Preferred direction
        pref_deg = np.angle(vector_sum) / np.pi * 180
        # Convert to 0–360 range
        pref_deg = (pref_deg + 360) % 360
        # Store preferred direction
        preferred_direction[sf][neuron] = pref_deg

        #DSI
        DSI_val = np.abs(vector_sum) / np.sum(responses)
        DSI[sf][neuron] = DSI_val


print("First 10 preferred directions SF=0.04:")
print(preferred_direction[0.04][:10])

print("First 10 DSI values SF=0.04:")
print(DSI[0.04][:10])


### PART 4: temporal frequency and orientation 
temp_freqs = np.sort(df_par.loc[:, 'temporal_frequency_in_Hz'].unique())
print("Temporal frequencies are:", temp_freqs)

# Dictionary: key = temporal frequency, value = 384×12 matrix (neurons × directions)
matrici_temp = {}

#loop over each temporal frequency
for tf in temp_freqs:
    # Rows corresponding to this temporal frequency
    rows_tf = df_par.index[df_par['temporal_frequency_in_Hz'] == sf].tolist()
    
    # matrix for this temporal frequency
    mat_tf = np.zeros((resp.shape[0], len(directions_sorted)))
    
    for i, dir_ in enumerate(directions_sorted):
        cols = df_par.index[
            (df_par['temporal_frequency_in_Hz'] == tf) &
            (df_par['direction_in_degrees'] == dir_)
        ].tolist()

        # Average across repetitions of this stimulus
        mat_tf[:, i] = df_resp.iloc[:, cols].mean(axis=1)

    # Save matrix
    matrici_temp[tf] = mat_tf
# Now 'matrici' contains 3 matrices, keys = spatial frequencies

mat_tf_1 = matrici_temp[1]
mat_tf_4 = matrici_temp[4]
print("Matrix 1 Hz temp freq with dimensions: ", mat_tf_1.shape)  # should be (384,12)
print(mat_tf_1)
print("Matrix 4 Hz temp freq with dimensions: ", mat_tf_4.shape)  # should be (384,12)
print(mat_tf_4)

#Part4.A: Firstly, direction-based matrices and tuning curves are calculated
#only in Part4.B: orientation tuning will be calculated from direction as it has only 6 unique orientations ( <-> direction 12)

# preferred direction and DSI

preferred_direction_temp = {}
DSI_temp = {}

for tf in temp_freqs: # Loop over temporal frequencies
    mat = matrici_temp[tf] # Matrix: 384 neurons × 12 directions
    
    preferred_direction_temp[tf] = np.zeros(mat.shape[0])
    DSI_temp[tf] = np.zeros(mat.shape[0])

    for neuron in range(mat.shape[0]): # Loop over each neuron
        responses = mat[neuron, :]

        # Complex vector sum for direction!
        vector_sum = np.sum(
            responses * np.exp(1j * directions_sorted / 180 * np.pi)
        )

        # preferred direction
        pref_deg = np.angle(vector_sum) * 180/np.pi
        pref_deg = (pref_deg + 360) % 360

        preferred_direction_temp[tf][neuron] = pref_deg

        # DSI
        DSI_temp[tf][neuron] = np.abs(vector_sum) / np.sum(responses)


print("\nExample: First 10 preferred temporal directions for TF =", temp_freqs[0])
print(preferred_direction_temp[temp_freqs[0]][:10])

print("\nExample: First 10 DSI values for TF =", temp_freqs[0])
print(DSI_temp[temp_freqs[0]][:10])

#PART 4.B: Orientation tuning matrices
# orientations = direction + 90 degrees 
# (orientations perpendicular to the motion direction (rotated by 90°))

# Compute orientation 
orientation = (direction + 90) % 180   # orientation is 0–179 degrees
df_par['orientation_in_degrees'] = orientation

orientations_sorted = np.sort(df_par['orientation_in_degrees'].unique())
print("\nOrientations in dataset:", orientations_sorted)

# Dictionary for orientation tuning matrices
matrici_orient = {}

for ori in orientations_sorted:

    mat_ori = np.zeros((resp.shape[0],))

matrici_orient = {}

for ori in orientations_sorted:

    # stimuli matching this orientation
    cols = df_par.index[df_par['orientation_in_degrees'] == ori].tolist()

    # matrix: 384 neurons × stimuli for that orientation
    mat = df_resp.iloc[:, cols].mean(axis=1)  # 384 values
    matrici_orient[ori] = mat.values  
print("\nCreated orientation response vectors (one value per neuron):")
for ori in orientations_sorted:
    print(f"Orientation {ori}° → vector length: {len(matrici_orient[ori])}")


# Preferred orientation + OSI (orientation selectivity index)
# Formula:
#   vector_sum = sum( responses * exp(2j * x) )
#   preferred_orientation = (angle(vector_sum)/2)  in degrees
#   OSI = |vector_sum| / sum(responses)


preferred_orientation = np.zeros((384,))
OSI = np.zeros((384,))

# neurons × orientations
orientation_matrix = np.zeros((384, len(orientations_sorted)))

for j, ori in enumerate(orientations_sorted):
    orientation_matrix[:, j] = matrici_orient[ori]


# OSI & preferred orientation
for neuron in range(384):

    responses = orientation_matrix[neuron, :]
    angles_rad = orientations_sorted * np.pi/180  

    #  exp(2j * x) 
    vector_sum = np.sum(responses * np.exp(2j * angles_rad))

    pref_ori = np.angle(vector_sum) * 180/np.pi     # radians → degrees
    pref_ori = pref_ori / 2                          # divide angle by 2 per assignment
    pref_ori = (pref_ori + 180) % 180                # orientation is 0–179

    preferred_orientation[neuron] = pref_ori
    OSI[neuron] = np.abs(vector_sum) / np.sum(responses)


print("\nFirst 10 Preferred Orientations:")
print(preferred_orientation[:10])

print("\nFirst 10 OSI values:")
print(OSI[:10])


# PLOTS (similar to Task 3)

plt.figure(figsize=(6,4))
plt.hist(OSI, bins=20)
plt.xlabel("OSI")
plt.ylabel("Number of neurons")
plt.title("Orientation Selectivity Index distribution")
plt.grid(True)
plt.show()

plt.figure(figsize=(6,4))
plt.hist(preferred_orientation, bins=18, range=(0,180))
plt.xlabel("Preferred Orientation (°)")
plt.ylabel("Number of neurons")
plt.title("Preferred orientation distribution (0–180°)")
plt.grid(True)
plt.show()
